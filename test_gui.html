<script>
/* -------------------------------------------------------
   ðŸ§© Utility + Initialization Script
------------------------------------------------------- */

let photoData = [null, null, null];
let qualityResults = [null, null, null];

function normalizeEndpoint(url) {
  return (url || '').trim().replace(/\/+$/, '');
}

function getCreds() {
  const apiEndpoint = normalizeEndpoint(document.getElementById('apiEndpoint').value);
  const apiKey = (document.getElementById('apiKey').value || '').trim();
  return { apiEndpoint, apiKey };
}

// Resize image client-side before uploading
function fileToResizedDataURL(file, maxSide = 1280, mime = 'image/jpeg', quality = 0.85) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const reader = new FileReader();
    reader.onload = e => {
      img.onload = () => {
        const canvas = document.createElement('canvas');
        let { width, height } = img;
        const scale = Math.min(1, maxSide / Math.max(width, height));
        width = Math.round(width * scale);
        height = Math.round(height * scale);
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        resolve(canvas.toDataURL(mime, quality));
      };
      img.onerror = reject;
      img.src = e.target.result;
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

// Clears old badges & messages when re-analyzing
function clearQualityUI() {
  for (let i = 1; i <= 3; i++) {
    const card = document.getElementById(`card${i}`);
    const preview = document.getElementById(`preview${i}`);
    card.classList.remove('quality-bad');
    const img = preview.querySelector('img.preview-image');
    preview.innerHTML = '';
    if (img) preview.appendChild(img);
  }
}

function estimateBase64KB(dataUrl) {
  const size = Math.ceil((dataUrl.length - dataUrl.indexOf(',') - 1) * 3 / 4);
  return Math.round(size / 1024);
}

function updateGenerateButton() {
  const allPhotosUploaded = photoData.every(p => p !== null);
  const apiEndpoint = document.getElementById('apiEndpoint').value;
  const apiKey = document.getElementById('apiKey').value;

  document.getElementById('generateBtn').disabled = 
      !allPhotosUploaded || !apiEndpoint || !apiKey;
}

// Set up photo inputs
for (let i = 1; i <= 3; i++) {
  const input = document.getElementById(`photo${i}`);
  const preview = document.getElementById(`preview${i}`);
  const card = document.getElementById(`card${i}`);

  input.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const dataUrl = await fileToResizedDataURL(file);
    photoData[i - 1] = dataUrl;

    const kb = estimateBase64KB(dataUrl);
    preview.innerHTML = `
      <img src="${dataUrl}" class="preview-image">
      <div>âœ“ Photo uploaded (${kb} KB)</div>
    `;
    card.classList.add('has-image');
    updateGenerateButton();
  });
}

document.getElementById('apiEndpoint').addEventListener('input', updateGenerateButton);
document.getElementById('apiKey').addEventListener('input', updateGenerateButton);
</script>
<script>
/* -------------------------------------------------------
   ðŸ” Analyze & Generate Handlers
------------------------------------------------------- */

document.getElementById('analyzeBtn').addEventListener('click', async () => {
  const { apiEndpoint, apiKey } = getCreds();
  if (!apiEndpoint || !/^https?:\/\//i.test(apiEndpoint) || !apiKey) {
    alert('Please enter a valid RunPod API endpoint (https://...) and API key');
    return;
  }

  const uploadedPhotos = photoData.filter(p => p !== null);
  if (uploadedPhotos.length === 0) {
    alert('Please upload at least one photo');
    return;
  }

  const btn = document.getElementById('analyzeBtn');
  btn.innerHTML = '<div class="spinner"></div> Analyzing...';
  btn.disabled = true;
  clearQualityUI();

  try {
    for (let i = 0; i < 3; i++) {
      if (!photoData[i]) continue;

      const response = await fetch(apiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          input: {
            action: 'analyze_photo',
            photo: photoData[i]
          }
        })
      });

      const raw = await response.json();
      const result = raw.output?.[0]?.output ?? raw.output ?? raw;
      qualityResults[i] = result;

      const card = document.getElementById(`card${i + 1}`);
      const preview = document.getElementById(`preview${i + 1}`);

      if (result.is_good) {
        card.classList.remove('quality-bad');
        preview.innerHTML += `
          <span class="quality-badge quality-good">âœ“ Good Quality</span>
        `;
      } else {
        card.classList.add('quality-bad');
        const issuesHtml = result.issues.map(issue => `â€¢ ${issue}`).join('<br>');
        preview.innerHTML += `
          <span class="quality-badge quality-bad">âœ— Quality Issues</span>
          <div class="quality-issues">${issuesHtml}</div>
        `;
      }
    }

    showResult('success', 'Photo quality analysis complete!');
  } catch (error) {
    showResult('error', `Error analyzing photos: ${error.message}`);
  } finally {
    btn.innerHTML = 'ðŸ” Analyze Photo Quality';
    btn.disabled = false;
  }
});

document.getElementById('generateBtn').addEventListener('click', async () => {
  const { apiEndpoint, apiKey } = getCreds();
  if (!apiEndpoint || !/^https?:\/\//i.test(apiEndpoint) || !apiKey) {
    alert('Please enter a valid RunPod API endpoint (https://...) and API key');
    return;
  }

  const measurements = {
    height: parseInt(document.getElementById('height').value),
    weight: parseInt(document.getElementById('weight').value),
    shoulderWidth: parseInt(document.getElementById('shoulder').value),
    chestCircumference: parseInt(document.getElementById('chest').value),
    waistCircumference: parseInt(document.getElementById('waist').value),
    hipCircumference: parseInt(document.getElementById('hips').value)
  };

  const btn = document.getElementById('generateBtn');
  btn.innerHTML = '<div class="spinner"></div> Generating Digital Twin...';
  btn.disabled = true;

  try {
    const response = await fetch(apiEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        input: {
          action: 'generate_twin',
          photos: photoData,
          measurements: measurements
        }
      })
    });

    const raw = await response.json();
    const result = raw.output?.[0]?.output ?? raw.output ?? raw;

    if (result.success) {
      showSuccessResult(result);
    } else {
      showResult('error', result.error || 'Failed to generate digital twin');
    }
  } catch (error) {
    showResult('error', `Error: ${error.message}`);
  } finally {
    btn.innerHTML = 'ðŸŽ¯ Generate Digital Twin';
    btn.disabled = false;
  }
});
</script>
<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/loaders/OBJLoader.js"></script>

<script>
/* -------------------------------------------------------
   ðŸ§  Result Display + Inline 3D Viewer
------------------------------------------------------- */

function showResult(type, message) {
  const section = document.getElementById('resultSection');
  const content = document.getElementById('resultContent');

  section.style.display = 'block';
  if (type === 'success') {
    content.innerHTML = `<div class="success-message">${message}</div>`;
  } else {
    content.innerHTML = `<div class="error-message">${message}</div>`;
  }
  section.scrollIntoView({ behavior: 'smooth' });
}

function showSuccessResult(result) {
  const section = document.getElementById('resultSection');
  const content = document.getElementById('resultContent');
  section.style.display = 'block';

  const stats = result.statistics;
  content.innerHTML = `
    <div class="success-message">
      <strong>âœ“ Digital Twin Generated Successfully!</strong>
    </div>
    <div class="stats-grid">
      <div class="stat-item"><div class="stat-value">${stats.num_vertices}</div><div class="stat-label">Vertices</div></div>
      <div class="stat-item"><div class="stat-value">${stats.num_faces}</div><div class="stat-label">Faces</div></div>
      <div class="stat-item"><div class="stat-value">${stats.num_matches}</div><div class="stat-label">Matches</div></div>
    </div>
    <div id="viewer" style="margin-top:20px;height:420px;background:#000;border-radius:10px;"></div>
    <div style="margin-top:20px;">
      <button onclick="downloadMesh('${result.mesh_obj_base64}')" 
        style="width:100%;padding:15px;background:#28a745;color:white;border:none;border-radius:10px;font-size:16px;cursor:pointer;">
        ðŸ“¥ Download OBJ File
      </button>
    </div>
  `;
  section.scrollIntoView({ behavior: 'smooth' });
  const objData = atob(result.mesh_obj_base64);
  showObjInViewer(objData);
}

let threeCtx = null;
function showObjInViewer(objText) {
  const container = document.getElementById('viewer');
  const w = container.clientWidth;
  const h = 420;
  if (!threeCtx) {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(w, h);
    container.innerHTML = '';
    container.appendChild(renderer.domElement);
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dir = new THREE.DirectionalLight(0xffffff, 0.7);
    dir.position.set(1, 1, 1);
    scene.add(dir);

    const loader = new THREE.OBJLoader();
    const obj = loader.parse(objText);
    obj.traverse(c => { if (c.isMesh) c.material = new THREE.MeshPhongMaterial({ color: 0xeeeeee }); });
    scene.add(obj);
    obj.rotation.x = -Math.PI / 2;
    obj.position.set(0, -0.5, 0);
    camera.position.set(0, 0.5, 2.5);

    function animate() {
      requestAnimationFrame(animate);
      obj.rotation.y += 0.01;
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      const w2 = container.clientWidth;
      renderer.setSize(w2, h);
      camera.aspect = w2 / h;
      camera.updateProjectionMatrix();
    });

    threeCtx = { scene, camera, renderer, obj };
  } else {
    const loader = new THREE.OBJLoader();
    const newObj = loader.parse(objText);
    const { scene } = threeCtx;
    scene.children = scene.children.filter(x => x.type !== 'Group');
    scene.add(newObj);
    threeCtx.obj = newObj;
  }
}

function downloadMesh(base64Data) {
  const objData = atob(base64Data);
  showObjInViewer(objData);
  const blob = new Blob([objData], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'digital_twin.obj';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
</script>
